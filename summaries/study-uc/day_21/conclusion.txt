一 文件锁的使用 读锁(共享锁)  写锁(互斥锁) 
	        建议锁       强制锁
	多进程使用锁对文件访问的步骤 1 加锁 2 失败 -> 不操作 成功 -> 对文件操作 3 操作完毕->解锁
	fcntl(2) 控制文件描述符等等一大坨功能
	#include <unistd.h>
        #include <fcntl.h>
	int fcntl(int fd, int cmd, ... /* arg */ );

二 标准库函数和系统调用之间的关系
   标准库函数 fopen(3) fclose(3) fputc(3) fgetc(3) fflush(3)(刷新缓冲区)... (vi *.i 看看结构体FILE有些什么)
   系统调用   open(2)  close(2)  read(2)  write(2)... 
		fopen(3)调用时先分配一块内存(里面包含了缓冲区),再调用open(2)得文件描述符,将其存到FILE._fileno中
		fget(3)如果缓冲区有足够的空间接纳字符,直接返回
		        如果不够,调用read(2)将数据从文件读取到缓冲区,然后再从缓冲区获取到数据返回
		fput(3)如果缓冲区有足够的空间接纳字符,就将字符直接放缓冲区即可返回
			如果不够,调用write(2)将缓冲区的数据写入文件,清理缓冲区,再将字符放缓冲区中
		fclose(3)首先清理缓冲区数据到文件,然后释放缓冲区,最后调用close(2)关闭文件
  使用库函数操作的文件称为缓冲文件,使用系统调用操作的文件称为非缓冲文件(使用库函数效率相对较高)
  编写程序的时候,尽量不要混用库函数和系统调用

三 文件操作的杂项
  access(2) getcwd(2) mkdir(2) rmdir(2) chdir(2) unmask(2) unlink/symlink(软链接)/link(2)(硬链接) rename(2) remove(3) chmod(2)...(自己下去扩充,那个上面也没有)

四 进程管理的基础
  进程是资源分配的基本单位,也是对使用到的资源的描述,
  每个进程都有自己的PCB和pid,PCB中记录了进程使用资源的情况
  所有的应用进程组成了一颗进程树.树根是init进程也就是1号进程.pid=1(pstree 查看进程树 ps -aux 查看进程 top 查看实时进程(ctrl c结束查看))
  进程间的关系: 父子关系 兄弟关系 
  创建子进程 pid_t fork(void)
  异步 同步 透明
  孤儿进程 父进程死了,把已经死了的父进程的子进程过继给init进程,子进程的父进程的init(1号进程)

  进程的退出
	return(只是从函数中放回,在main()中返回代表进程结束,其实也没结束) 和 exit(3)(终止当前进程)
  遗言函数的使用  进程再死之前要处理一些事情,调用函数执行这些事情
		  在进程死之前要注册遗言函数,在进程死后执行遗言函数
  atexit(3)(调用的顺序与注册的顺序相反/同一个函数被注册一次就被调用一次/子进程继承父进程的遗言函数) 
  on_exit(3) 给进程注册遗言函数

五 进程资源的回收
   进程执行会占用资源,进程终止时将资源释放给系统,由父进程回收子进程
	wait(2)家族的函数用于回收进程的资源
		pid_t wait(int *status)等待子进程终止,回收其资源
		pid_t waitpid(pid_t pid, int *status, )

   kill -信号编号 pid 给pid进程发送信号

六 wait(2) waitpid(2)




五 补充知识
   有符号的整数在计算机里是怎样存储的(列如 -1 ) 以补码的方式存储
	abs(-1)=1 => 000000000,000000000,000000000,00000001 => 按位取反加一
		     111111111,111111111,111111111,11111110 + 1 = 111111111,111111111,111111111,11111111

 
